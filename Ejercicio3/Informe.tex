\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{cite}
\usepackage{listings}
\usepackage{xcolor}

% Configuración para código Python
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)},
    xleftmargin=2em,
    framexleftmargin=1.5em
}

\title{Ejercicio 3: Alineación de Secuencias de Nucleótidos\\
\large Algoritmo de Needleman-Wunsch}
\author{Fabricio Denardi}
\date{Diciembre 2025}

\begin{document}

\maketitle

\section{Parte 1: Conceptos Teóricos}

\subsection{Secuencias de Nucleótidos y su Importancia}

Las secuencias de nucleótidos se refieren a cadenas de bases que forman el ADN o ARN de cualquier organismo vivo. En el ADN se encuentran cuatro bases nitrogenadas principales: adenina (A), timina (T), guanina (G) y citosina (C). Por su parte, el ARN es bastante parecido, solo que la timina es sustituida por uracilo (U). Estas secuencias no son solo combinaciones aleatorias, sino que guardan toda la información genética necesaria para producir proteínas y mantener funcionando las células.

La comparación de estas secuencias resulta fundamental en biología molecular por varios motivos:

\begin{itemize}
    \item Cuando dos organismos tienen secuencias parecidas, es muy probable que compartan un ancestro común. Esto permite armar árboles evolutivos que muestran cómo están relacionadas las especies.
    \item Si se encuentran genes similares en organismos distintos, se puede predecir qué función tienen incluso sin haberlos estudiado directamente.
    \item En medicina, comparar secuencias ayuda a detectar mutaciones que causan enfermedades hereditarias.
    \item Para la biotecnología moderna, esto es clave: desde diseñar los primers que se usan en PCR hasta desarrollar nuevas vacunas o terapias génicas.
\end{itemize}

\subsection{Alineación de Secuencias}

Alinear secuencias significa organizarlas de tal manera que se puedan identificar qué partes se parecen entre sí. No es simplemente ponerlas una al lado de la otra, sino encontrar la mejor forma de disponerlas para ver patrones que indiquen algo sobre su relación evolutiva o funcional.

\subsubsection{Tipos de Alineación}

\paragraph{Alineación Global:} Se comparan las secuencias completas, desde el primer nucleótido hasta el último. Funciona mejor cuando las secuencias tienen tamaños parecidos y se encuentran relacionadas en toda su longitud. El algoritmo de Needleman-Wunsch, que es el que se usa en este trabajo, hace precisamente esto.

\paragraph{Alineación Local:} A veces no interesa comparar todo, sino buscar regiones específicas que sean similares dentro de secuencias más largas. Es útil cuando se sabe que solo ciertos dominios o fragmentos son parecidos. Para esto existe el algoritmo de Smith-Waterman.

\subsubsection{Elementos de un Alineamiento}

\begin{itemize}
    \item Coincidencias (matches): son posiciones donde los nucleótidos de ambas secuencias son exactamente iguales. Cuando se observan muchas coincidencias, generalmente significa que esa región se ha conservado bastante bien a lo largo de la evolución, probablemente porque es importante funcionalmente.
    
    \item Desajustes (mismatches): son posiciones donde los nucleótidos difieren. Podría tratarse de mutaciones puntuales que ocurrieron en algún momento de la historia evolutiva de estas secuencias. No siempre son "malas", a veces estas diferencias son las que generan diversidad.
    
    \item Huecos (gaps): representan lugares donde parece que se insertó o eliminó algo en una de las secuencias respecto a la otra. Se introducen estratégicamente durante el alineamiento para que todo encaje mejor. En términos evolutivos, reflejan eventos de inserción o eliminación de nucleótidos que pueden haber ocurrido hace millones de años.
\end{itemize}

\subsection{Modelo de Puntuación}

Para decidir qué tan bueno es un alineamiento, se necesita alguna forma de "calificarlo". Aquí es donde entra el modelo de puntuación, que básicamente asigna valores a cada tipo de evento que puede ocurrir en el alineamiento.

\subsubsection{Reglas de Puntuación Básicas}

\begin{itemize}
    \item Match: cuando dos nucleótidos coinciden, se asignan puntos positivos. En el caso simple, se usa $+1$.
    
    \item Mismatch: si no coinciden, hay que penalizar. Se resta $-1$.
\end{itemize}

Ahora bien, esto es el esquema más básico. Cuando se trabaja con proteínas o se requiere algo más sofisticado, se pueden usar matrices especiales (como BLOSUM o PAM) que consideran cuán probable es evolutivamente cada tipo específico de mutación.

\subsubsection{Penalización por Huecos}

Los gaps son un tema aparte. Si no se penalizaran lo suficiente, el algoritmo podría llenar el alineamiento de huecos por todas partes, lo cual no tendría mucho sentido biológico:

\begin{itemize}
    \item Penalización por apertura de gap: es el costo que se paga al crear un nuevo hueco. En el modelo simple, se usa $-2$.
    
    \item Penalización por extensión de gap: algunos algoritmos más avanzados cobran extra por cada posición adicional que se extiende un gap. La fórmula típica es $\text{penalty} = d + e \times k$, donde $d$ es abrir el gap, $e$ es extenderlo, y $k$ es qué tan largo es.
\end{itemize}

Para simplificar, en la implementación cada gap cuesta $-2$ fijo, sin importar cuánto mida. Esto hace las cosas más sencillas, aunque se sacrifica un poco de precisión biológica.

\subsection{Algoritmo de Needleman-Wunsch}

El algoritmo de Needleman-Wunsch apareció en 1970 y fue revolucionario para la bioinformática. Usa una técnica llamada programación dinámica que básicamente significa que va resolviendo el problema grande dividiéndolo en pedacitos más pequeños. Lo importante es que garantiza encontrar el mejor alineamiento global posible entre dos secuencias, no solo "uno bueno", sino el óptimo.

\subsubsection{Construcción de la Matriz de Programación Dinámica}

Lo primero que hace el algoritmo es crear una matriz $M$ de tamaño $(n+1) \times (m+1)$, donde $n$ y $m$ son las longitudes de las dos secuencias.

\paragraph{Inicialización:}
\begin{itemize}
    \item Se coloca $M[0,0] = 0$, que representa alinear dos secuencias vacías (obviamente cuesta 0)
    \item La primera fila se llena con: $M[0,j] = j \times \text{gap\_penalty}$ para $j = 1, \ldots, m$
    \item Lo mismo con la primera columna: $M[i,0] = i \times \text{gap\_penalty}$ para $i = 1, \ldots, n$
\end{itemize}

Esto tiene sentido: alinear una secuencia con "nada" solo puede hacerse metiendo gaps, y hay que pagar el precio por cada uno.

\subsubsection{Ecuación de Recurrencia}

Para llenar cada casilla $M[i,j]$, el algoritmo evalúa tres opciones y se queda con la que dé el mejor puntaje:

\begin{equation}
M[i,j] = \max \begin{cases}
M[i-1,j-1] + s(x_i, y_j) & \text{(diagonal: match/mismatch)} \\
M[i-1,j] + \text{gap} & \text{(arriba: gap en seq2)} \\
M[i,j-1] + \text{gap} & \text{(izquierda: gap en seq1)}
\end{cases}
\end{equation}

donde $s(x_i, y_j)$ es simplemente el puntaje que obtenemos al emparejar $x_i$ con $y_j$:

\begin{equation}
s(x_i, y_j) = \begin{cases}
\text{match} & \text{si } x_i = y_j \\
\text{mismatch} & \text{si } x_i \neq y_j
\end{cases}
\end{equation}

Este enfoque implementa algo conocido como el "principio de optimalidad de Bellman", que básicamente dice que si construyes la mejor solución usando las mejores soluciones de problemas más chicos, al final obtienes lo óptimo para el problema completo. Medio recursivo conceptualmente, pero funciona perfecto.

\subsubsection{Proceso de Traceback}

Una vez construida la matriz completa, el score óptimo se encuentra en $M[n,m]$. Para recuperar el alineamiento que produjo ese score:

\begin{enumerate}
    \item Inicio: comenzar en la celda $M[n,m]$ (esquina inferior derecha)
    
    \item Recorrido: en cada paso, determinar de qué celda provino el valor actual:
    \begin{itemize}
        \item Si $M[i,j]$ vino de $M[i-1,j-1]$: alinear $x_i$ con $y_j$ (movimiento diagonal)
        \item Si $M[i,j]$ vino de $M[i-1,j]$: alinear $x_i$ con gap (movimiento vertical)
        \item Si $M[i,j]$ vino de $M[i,j-1]$: alinear gap con $y_j$ (movimiento horizontal)
    \end{itemize}
    
    \item Terminación: continuar hasta llegar a $M[0,0]$
    
    \item Reversión: como el alineamiento se construyó de atrás hacia adelante, invertirlo para obtener el orden correcto
\end{enumerate}

\subsubsection{Complejidad Computacional}

En términos de eficiencia, el algoritmo funciona así:
\begin{itemize}
    \item Tiempo de ejecución: $O(n \times m)$ para armar toda la matriz
    \item Memoria que necesita: $O(n \times m)$ para guardarla
\end{itemize}

Si se trabaja con secuencias enormes (por ejemplo genomas completos), existen algunos trucos de optimización que permiten reducir el uso de memoria a $O(\min(n,m))$. Se sacrifica un poco de conveniencia pero se ahorra espacio.

\section{Parte 2: Implementación del Algoritmo}

\subsection{repositorio}
El repositorio del código puede encontrarse en: \url{https://github.com/denardifabricio/MIA_01c_CAED/tree/main/Ejercicio3a}

\subsection{Descripción General del Código}
El código completo puede revisarse en el archivo \texttt{needleman\_wunsch.py} en el repositorio. A continuación se describe cómo está organizado:

Se implementó el algoritmo de Needleman-Wunsch en Python de forma modular, con varias funciones que se encargan de diferentes partes del proceso:



\subsubsection{Función \texttt{needleman\_wunsch()}}

Esta es el corazón del programa. Aquí es donde ocurre el procesamiento principal del algoritmo:

\begin{enumerate}
    \item Primero se crea una matriz del tamaño necesario y se inicializa con las penalizaciones de gaps en los bordes, como se explicó anteriormente.
    
    \item Después viene el llenado: se recorre cada celda calculando el mejor puntaje posible según las tres opciones disponibles (diagonal, arriba o izquierda).
    
    \item Una vez llena la matriz, se hace el traceback para recuperar cómo quedó el alineamiento óptimo. Se retrocede desde la última celda hasta el principio.
    
    \item Finalmente se devuelve todo: la matriz completa, las dos secuencias alineadas (con sus gaps incluidos) y el puntaje final.
\end{enumerate}

A continuación se muestran algunos fragmentos del código:

\begin{lstlisting}[caption={Inicialización de la matriz y condiciones de frontera}]
# Crear matriz de dimensiones (n+1) x (m+1)
n_rows = len(seq1)
n_cols = len(seq2)
matriz = [[0 for _ in range(n_cols + 1)] 
          for _ in range(n_rows + 1)]

# Inicializar primera fila y columna con penalizaciones
for i in range(n_rows + 1):
    matriz[i][0] = i * gap
for j in range(n_cols + 1):
    matriz[0][j] = j * gap
\end{lstlisting}

Código de llenado de la matriz con programación dinámica:

\begin{lstlisting}[caption={Ecuación de recurrencia - Llenado de la matriz}]
for i in range(1, n_rows + 1):
    for j in range(1, n_cols + 1):
        # Calcular score diagonal (match o mismatch)
        if seq1[i-1] == seq2[j-1]:
            diagonal_score = matriz[i-1][j-1] + match
        else:
            diagonal_score = matriz[i-1][j-1] + mismatch
        
        # Calcular scores con gaps
        up_score = matriz[i-1][j] + gap      # Gap en seq2
        left_score = matriz[i][j-1] + gap    # Gap en seq1
        
        # Tomar el maximo (decision optima)
        matriz[i][j] = max(diagonal_score, up_score, 
                          left_score)
\end{lstlisting}

Código del proceso de traceback:

\begin{lstlisting}[caption={Traceback para recuperar el alineamiento óptimo}]
alignment1 = []
alignment2 = []
i = n_rows
j = n_cols

while i > 0 or j > 0:
    if j == 0:
        # Solo gaps en seq2
        alignment1.append(seq1[i-1])
        alignment2.append('-')
        i -= 1
    elif i == 0:
        # Solo gaps en seq1
        alignment1.append('-')
        alignment2.append(seq2[j-1])
        j -= 1
    else:
        # Determinar de donde vino el valor actual
        if seq1[i-1] == seq2[j-1]:
            diagonal_score = matriz[i-1][j-1] + match
        else:
            diagonal_score = matriz[i-1][j-1] + mismatch
        
        up_score = matriz[i-1][j] + gap
        left_score = matriz[i][j-1] + gap
        
        # Elegir el camino que produjo el valor
        if matriz[i][j] == diagonal_score:
            alignment1.append(seq1[i-1])
            alignment2.append(seq2[j-1])
            i -= 1
            j -= 1
        elif matriz[i][j] == up_score:
            alignment1.append(seq1[i-1])
            alignment2.append('-')
            i -= 1
        else:
            alignment1.append('-')
            alignment2.append(seq2[j-1])
            j -= 1

# Invertir los alineamientos
alignment1 = ''.join(reversed(alignment1))
alignment2 = ''.join(reversed(alignment2))
\end{lstlisting}

\subsubsection{Funciones de Visualización}

Para facilitar la visualización, se implementaron algunas funciones auxiliares:

\begin{itemize}
    \item \texttt{print\_matrix()}: muestra la matriz de puntuación de una forma clara y ordenada, con los encabezados de las secuencias para que sea más fácil interpretarla.
    
    \item \texttt{print\_alignment()}: muestra el alineamiento con símbolos visuales intuitivos:
    \begin{itemize}
        \item Un \texttt{|} cuando hay un match perfecto
        \item Un \texttt{*} para los mismatches
        \item Un espacio en blanco donde hay gaps
    \end{itemize}
    Así de un vistazo se puede ver qué tan bien alinearon las secuencias.
    
    \item \texttt{analyze\_alignment()}: hace el análisis cuantitativo. Cuenta cuántos matches, mismatches y gaps hay, y calcula el porcentaje de identidad entre las secuencias.
\end{itemize}

Código para análisis de estadísticas:

\begin{lstlisting}[caption={Análisis estadístico del alineamiento}]
num_matches = 0
num_mismatches = 0
num_gaps = 0

for i in range(len(alignment1)):
    if alignment1[i] == '-' or alignment2[i] == '-':
        num_gaps += 1              # Gap
    elif alignment1[i] == alignment2[i]:
        num_matches += 1           # Match
    else:
        num_mismatches += 1        # Mismatch

longitud_total = len(alignment1)
porcentaje_identidad = (num_matches / longitud_total) * 100

print(f"Longitud del alineamiento: {longitud_total}")
print(f"Coincidencias (matches):   {num_matches}")
print(f"Desajustes (mismatches):   {num_mismatches}")
print(f"Huecos (gaps):             {num_gaps}")
print(f"Identidad:                 {porcentaje_identidad:.2f}%")
\end{lstlisting}

\subsubsection{Esquema de Puntuación Implementado}

Se usa un modelo de puntuación bastante directo y simple:

\begin{itemize}
    \item Match: $+1$ (se asigna un punto cuando coinciden)
    \item Mismatch: $-1$ (se resta uno cuando no coinciden)
    \item Gap: $-2$ (se penaliza más los huecos)
\end{itemize}

Con este esquema se indica que se prefiere matchear los nucleótidos cuando sea posible, pero si hay que elegir entre un mismatch y un gap, se prefiere el mismatch. Esto tiene sentido biológicamente porque las mutaciones puntuales (sustituciones) suelen ser más comunes que las inserciones o eliminaciones grandes en secuencias relacionadas evolutivamente.

Código de definición de parámetros:

\begin{lstlisting}[caption={Parámetros del modelo de puntuación}]
def needleman_wunsch(seq1, seq2, match=1, mismatch=-1, gap=-2):
    """
    Implementa el algoritmo de Needleman-Wunsch
    
    Parametros:
    - match: +1 (recompensa por coincidencia)
    - mismatch: -1 (penalizacion por desajuste)
    - gap: -2 (penalizacion por hueco)
    """
    # ... implementacion del algoritmo ...
\end{lstlisting}

Ejemplo de uso del programa:

\begin{lstlisting}[caption={Ejemplo de ejecución con parejas de secuencias}]
# Definir parejas de secuencias a analizar
parejas_secuencias = [
    ("GATTACA", "GCATGCU"),    # Caso clasico
    ("ACGT", "ACCT"),          # Secuencias cortas
    ("ATGCT", "AGCT"),         # Requiere gaps
]

# Parametros de puntuacion
MATCH = 1
MISMATCH = -1
GAP = -2

# Procesar cada pareja
for seq1, seq2 in parejas_secuencias:
    matriz, alineamiento1, alineamiento2, puntaje = \
        needleman_wunsch(seq1, seq2, MATCH, MISMATCH, GAP)
    
    # Mostrar resultados
    print_matrix(matriz, seq1, seq2)
    print_alignment(alineamiento1, alineamiento2, seq1, seq2)
    analyze_alignment(alineamiento1, alineamiento2, 
                     MATCH, MISMATCH, GAP)
\end{lstlisting}

\subsection{Casos de Prueba}

Para probar el programa, se prepararon 10 parejas diferentes de secuencias. Cada una representa un escenario distinto:

\begin{enumerate}
    \item ("GATTACA", "GCATGCU"): este es el ejemplo clásico que aparece en la literatura - tiene varios mismatches interesantes
    \item ("ACGT", "ACCT"): secuencias cortas y simples, solo un mismatch
    \item ("ATGCT", "AGCT"): se necesita introducir un gap para obtener un buen alineamiento
    \item Se incluyen casos con secuencias de distintos largos, algunas muy parecidas, otras que necesitan varios gaps, etc.
\end{enumerate}

Para cada pareja, el programa muestra información detallada:
\begin{itemize}
    \item Toda la matriz de puntuación (para poder observar cómo razona el algoritmo)
    \item El alineamiento óptimo encontrado
    \item Todas las estadísticas: matches, mismatches, gaps, porcentaje de identidad
    \item El puntaje final que obtuvo ese alineamiento
\end{itemize}

\subsection{Características Técnicas}

\begin{itemize}
    \item Lenguaje: Python 3
    \item Complejidad temporal: $O(n \times m)$ donde $n$ y $m$ son las longitudes de las secuencias
    \item Complejidad espacial: $O(n \times m)$ para almacenar la matriz completa
    \item Documentación: el código incluye comentarios extensos explicando la teoria detrás de cada paso
    \item Modularidad: funciones separadas para diferentes aspectos del analisis, facilitando mantenimiento y reutilización
\end{itemize}

\subsection{Ejemplo de Resultado}

A continuación se muestra el resultado de alinear \texttt{("GATTACA", "GCATGCU")}:

\begin{verbatim}
Alineamiento óptimo:
Seq1: GATTACA
      |**|*|*
Seq2: GCATGCU

Estadísticas:
- Longitud: 7
- Matches: 3 (+3 puntos)
- Mismatches: 4 (-4 puntos)
- Gaps: 0 (+0 puntos)
- Identidad: 42.86%
- Puntaje final: -1
\end{verbatim}

Se puede observar que aunque comparten algunas posiciones (las que tienen el \texttt{|}), hay bastantes diferencias (los \texttt{*}). El puntaje negativo indica que, en general, estas secuencias no son muy similares. Un 42.86\% de identidad es relativamente bajo - en biología, secuencias con menos del 50\% de identidad generalmente no se consideran homólogas.



\section{Referencias}

\begin{thebibliography}{9}

\bibitem{needleman1970}
Needleman, S. B., \& Wunsch, C. D. (1970). 
\textit{A general method applicable to the search for similarities in the amino acid sequence of two proteins}. 
Journal of Molecular Biology, 48(3), 443-453.
Link: \url{https://web.stanford.edu/class/sbio228/public/readings/Bioinformatics_I_Lecture6/Needleman_Wunsch_JMB_70_Global_alignment.pdf?utm_source=chatgpt.com}



\bibitem{anandakumar2020}
Anandakumar, M. (2020). 
\textit{Needleman-Wunsch algorithm for DNA sequence alignment}. 
Medium.
Link: \url{https://medium.com/@amithunjha/needleman-wunsch-algorithm-for-dna-sequence-alignment-b103b8454de0}


\bibitem{needlemanWIKI}
Wikipedia contributors. (2025). 
\textit{Needleman–Wunsch algorithm}. 
In Wikipedia, The Free Encyclopedia.
Link: \url{https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm}

\end{thebibliography}



\end{document}