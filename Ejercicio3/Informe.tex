\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage{hyperref}
\usepackage{cite}
\usepackage{listings}
\usepackage{xcolor}

% Configuración para código Python
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)},
    xleftmargin=2em,
    framexleftmargin=1.5em
}

\title{Ejercicio 3: Alineación de Secuencias de Nucleótidos\\
\large Algoritmo de Needleman-Wunsch}
\author{Fabricio Denardi}
\date{Diciembre 2025}

\begin{document}

\maketitle

\section{Parte 1: Conceptos Teóricos}

\subsection{Secuencias de Nucleótidos y su Importancia}

Cuando hablamos de secuencias de nucleótidos, nos referimos básicamente a esas cadenas de "letras" que forman el ADN o ARN de cualquier organismo vivo. En el ADN encontramos cuatro bases nitrogenadas principales: adenina (A), timina (T), guanina (G) y citosina (C). Por su parte, el ARN es bastante parecido, solo que la timina es sustituida por uracilo (U). Lo interesante es que estas secuencias no son solo combinaciones aleatorias, sino que guardan toda la información genética necesaria para producir proteínas y mantener funcionando las células.

¿Por qué es tan importante comparar estas secuencias? En biología molecular resulta fundamental por varios motivos:

\begin{itemize}
    \item Cuando dos organismos tienen secuencias parecidas, es muy probable que compartan un ancestro común. Esto nos permite armar esos árboles evolutivos que muestran cómo están relacionadas las especies.
    \item Si encontramos genes similares en organismos distintos, podemos predecir qué función tienen incluso sin haberlos estudiado directamente.
    \item En medicina, comparar secuencias nos ayuda muchísimo para detectar mutaciones que causan enfermedades hereditarias.
    \item Para la biotecnología moderna, esto es clave: desde diseñar los primers que usamos en PCR hasta desarrollar nuevas vacunas o terapias génicas.
\end{itemize}

\subsection{Alineación de Secuencias}

Alinear secuencias significa organizarlas de tal manera que podamos identificar qué partes se parecen entre sí. No es simplemente ponerlas una al lado de la otra, sino encontrar la mejor forma de disponerlas para ver patrones que nos digan algo sobre su relación evolutiva o funcional.

\subsubsection{Tipos de Alineación}

\paragraph{Alineación Global:} Aquí comparamos las secuencias completas, desde el primer nucleótido hasta el último. Funciona mejor cuando las secuencias tienen tamaños parecidos y creemos que están relacionadas en toda su longitud. El algoritmo de Needleman-Wunsch, que es el que vamos a usar en este trabajo, hace precisamente esto.

\paragraph{Alineación Local:} A veces no nos interesa comparar todo, sino buscar regiones específicas que sean similares dentro de secuencias más largas. Es útil cuando sabemos que solo ciertos dominios o fragmentos son parecidos. Para esto existe el algoritmo de Smith-Waterman.

\subsubsection{Elementos de un Alineamiento}

\begin{itemize}
    \item Coincidencias (matches): son esas posiciones donde los nucleótidos de ambas secuencias son exactamente iguales. Cuando vemos muchas coincidencias, generalmente significa que esa región se ha conservado bastante bien a lo largo de la evolución, probablemente porque es importante funcionalmente.
    
    \item Desajustes (mismatches): aquí es donde los nucleótidos difieren. Podría tratarse de mutaciones puntuales que ocurrieron en algún momento de la historia evolutiva de estas secuencias. No siempre son "malas", a veces estas diferencias son las que generan diversidad.
    
    \item Huecos (gaps): estos representan lugares donde parece que se insertó o eliminó algo en una de las secuencias respecto a la otra. Los introducimos estratégicamente durante el alineamiento para que todo encaje mejor. En términos evolutivos, reflejan eventos de inserción o eliminación de nucleótidos que pueden haber ocurrido hace millones de años.
\end{itemize}

\subsection{Modelo de Puntuación}

Para decidir qué tan bueno es un alineamiento, necesitamos alguna forma de "calificarlo". Aquí es donde entra el modelo de puntuación, que básicamente asigna valores a cada tipo de evento que puede ocurrir en el alineamiento.

\subsubsection{Reglas de Puntuación Básicas}

\begin{itemize}
    \item Match: cuando dos nucleótidos coinciden, le damos puntos positivos. En nuestro caso simple, usamos $+1$.
    
    \item Mismatch: si no coinciden, hay que penalizar. Aquí restamos $-1$.
\end{itemize}

Ahora bien, esto es el esquema más básico. Cuando trabajamos con proteínas o queremos algo más sofisticado, podemos usar matrices especiales (como BLOSUM o PAM) que consideran cuán probable es evolutivamente cada tipo específico de mutación.

\subsubsection{Penalización por Huecos}

Los gaps son un tema aparte. Si no los penalizáramos lo suficiente, el algoritmo podría llenar el alineamiento de huecos por todas partes, lo cual no tendría mucho sentido biológico:

\begin{itemize}
    \item Penalización por apertura de gap: es el costo que pagamos al crear un nuevo hueco. En nuestro modelo simple, usamos $-2$.
    
    \item Penalización por extensión de gap: algunos algoritmos más avanzados cobran extra por cada posición adicional que se extiende un gap. La fórmula típica es $\text{penalty} = d + e \times k$, donde $d$ es abrir el gap, $e$ es extenderlo, y $k$ es qué tan largo es.
\end{itemize}

Para simplificar, en nuestra implementación cada gap cuesta $-2$ fijo, sin importar cuánto mida. Esto hace las cosas más sencillas, aunque sacrificamos un poco de precisión biológica.

\subsection{Algoritmo de Needleman-Wunsch}

El algoritmo de Needleman-Wunsch apareció en 1970 y fue revolucionario para la bioinformática. Usa una técnica llamada programación dinámica que, aunque suena complicado, básicamente significa que va resolviendo el problema grande dividiéndolo en pedacitos más pequeños. Lo genial es que garantiza encontrar el mejor alineamiento global posible entre dos secuencias, no solo "uno bueno", sino el óptimo.

\subsubsection{Construcción de la Matriz de Programación Dinámica}

Lo primero que hace el algoritmo es crear una matriz $M$ de tamaño $(n+1) \times (m+1)$, donde $n$ y $m$ son las longitudes de nuestras dos secuencias.

\paragraph{Inicialización:}
\begin{itemize}
    \item Empezamos poniendo $M[0,0] = 0$, que representa alinear dos secuencias vacías (obvio que cuesta 0)
    \item La primera fila va llenándose: $M[0,j] = j \times \text{gap\_penalty}$ para $j = 1, \ldots, m$
    \item Lo mismo con la primera columna: $M[i,0] = i \times \text{gap\_penalty}$ para $i = 1, \ldots, n$
\end{itemize}

Esto tiene sentido si lo piensas: alinear una secuencia con "nada" solo puede hacerse metiendo gaps, y hay que pagar el precio por cada uno.

\subsubsection{Ecuación de Recurrencia}

Para llenar cada casilla $M[i,j]$, el algoritmo evalúa tres opciones y se queda con la que dé el mejor puntaje:

\begin{equation}
M[i,j] = \max \begin{cases}
M[i-1,j-1] + s(x_i, y_j) & \text{(diagonal: match/mismatch)} \\
M[i-1,j] + \text{gap} & \text{(arriba: gap en seq2)} \\
M[i,j-1] + \text{gap} & \text{(izquierda: gap en seq1)}
\end{cases}
\end{equation}

donde $s(x_i, y_j)$ es simplemente el puntaje que obtenemos al emparejar $x_i$ con $y_j$:

\begin{equation}
s(x_i, y_j) = \begin{cases}
\text{match} & \text{si } x_i = y_j \\
\text{mismatch} & \text{si } x_i \neq y_j
\end{cases}
\end{equation}

Este enfoque implementa algo conocido como el "principio de optimalidad de Bellman", que básicamente dice que si construyes la mejor solución usando las mejores soluciones de problemas más chicos, al final obtienes lo óptimo para el problema completo. Medio recursivo conceptualmente, pero funciona perfecto.

\subsubsection{Proceso de Traceback}

Una vez construida la matriz completa, el score óptimo se encuentra en $M[n,m]$. Para recuperar el alineamiento que produjo ese score:

\begin{enumerate}
    \item Inicio: comenzar en la celda $M[n,m]$ (esquina inferior derecha)
    
    \item Recorrido: en cada paso, determinar de qué celda provino el valor actual:
    \begin{itemize}
        \item Si $M[i,j]$ vino de $M[i-1,j-1]$: alinear $x_i$ con $y_j$ (movimiento diagonal)
        \item Si $M[i,j]$ vino de $M[i-1,j]$: alinear $x_i$ con gap (movimiento vertical)
        \item Si $M[i,j]$ vino de $M[i,j-1]$: alinear gap con $y_j$ (movimiento horizontal)
    \end{itemize}
    
    \item Terminación: continuar hasta llegar a $M[0,0]$
    
    \item Reversión: como el alineamiento se construyó de atrás hacia adelante, invertirlo para obtener el orden correcto
\end{enumerate}

\subsubsection{Complejidad Computacional}

En términos de eficiencia, el algoritmo funciona así:
\begin{itemize}
    \item Tiempo de ejecución: $O(n \times m)$ para armar toda la matriz
    \item Memoria que necesita: $O(n \times m)$ para guardarla
\end{itemize}

Si trabajamos con secuencias enormes (pensá en genomas completos), existen algunos trucos de optimización que permiten reducir el uso de memoria a $O(\min(n,m))$. Sacrificás un poco de conveniencia pero ahorrás bastante espacio.

\section{Parte 2: Implementación del Algoritmo}

\subsection{repositorio}
El repositorio del código puede encontrarse en: \url{https://github.com/denardifabricio/MIA_01c_CAED/tree/main/Ejercicio3a}

\subsection{Descripción General del Código}
Los invito a revisar el código completo en el archivo \texttt{needleman\_wunsch.py} en el repositorio, pero déjenme contarles un poco cómo está organizado todo:

Implementé el algoritmo de Needleman-Wunsch en Python pensando en que sea fácil de entender y usar. Lo armé de forma modular, con varias funciones que se encargan de diferentes partes del proceso:



\subsubsection{Función \texttt{needleman\_wunsch()}}

Esta es el corazón del programa. Acá es donde ocurre toda la magia del algoritmo:

\begin{enumerate}
    \item Primero creo una matriz del tamaño necesario y la inicializo con las penalizaciones de gaps en los bordes, como explicamos antes.
    
    \item Después viene el llenado: recorro cada celda calculando el mejor puntaje posible según las tres opciones que tenemos (diagonal, arriba o izquierda).
    
    \item Una vez llena la matriz, hago el traceback para recuperar cómo quedó el alineamiento óptimo. Voy retrocediendo desde la última celda hasta el principio.
    
    \item Finalmente devuelvo todo: la matriz completa, las dos secuencias alineadas (con sus gaps incluidos) y el puntaje final.
\end{enumerate}

Veamos algunos fragmentos del código para que se entienda mejor:

\begin{lstlisting}[caption={Inicialización de la matriz y condiciones de frontera}]
# Crear matriz de dimensiones (n+1) x (m+1)
n_rows = len(seq1)
n_cols = len(seq2)
matriz = [[0 for _ in range(n_cols + 1)] 
          for _ in range(n_rows + 1)]

# Inicializar primera fila y columna con penalizaciones
for i in range(n_rows + 1):
    matriz[i][0] = i * gap
for j in range(n_cols + 1):
    matriz[0][j] = j * gap
\end{lstlisting}

Código de llenado de la matriz con programación dinámica:

\begin{lstlisting}[caption={Ecuación de recurrencia - Llenado de la matriz}]
for i in range(1, n_rows + 1):
    for j in range(1, n_cols + 1):
        # Calcular score diagonal (match o mismatch)
        if seq1[i-1] == seq2[j-1]:
            diagonal_score = matriz[i-1][j-1] + match
        else:
            diagonal_score = matriz[i-1][j-1] + mismatch
        
        # Calcular scores con gaps
        up_score = matriz[i-1][j] + gap      # Gap en seq2
        left_score = matriz[i][j-1] + gap    # Gap en seq1
        
        # Tomar el maximo (decision optima)
        matriz[i][j] = max(diagonal_score, up_score, 
                          left_score)
\end{lstlisting}

Código del proceso de traceback:

\begin{lstlisting}[caption={Traceback para recuperar el alineamiento óptimo}]
alignment1 = []
alignment2 = []
i = n_rows
j = n_cols

while i > 0 or j > 0:
    if j == 0:
        # Solo gaps en seq2
        alignment1.append(seq1[i-1])
        alignment2.append('-')
        i -= 1
    elif i == 0:
        # Solo gaps en seq1
        alignment1.append('-')
        alignment2.append(seq2[j-1])
        j -= 1
    else:
        # Determinar de donde vino el valor actual
        if seq1[i-1] == seq2[j-1]:
            diagonal_score = matriz[i-1][j-1] + match
        else:
            diagonal_score = matriz[i-1][j-1] + mismatch
        
        up_score = matriz[i-1][j] + gap
        left_score = matriz[i][j-1] + gap
        
        # Elegir el camino que produjo el valor
        if matriz[i][j] == diagonal_score:
            alignment1.append(seq1[i-1])
            alignment2.append(seq2[j-1])
            i -= 1
            j -= 1
        elif matriz[i][j] == up_score:
            alignment1.append(seq1[i-1])
            alignment2.append('-')
            i -= 1
        else:
            alignment1.append('-')
            alignment2.append(seq2[j-1])
            j -= 1

# Invertir los alineamientos
alignment1 = ''.join(reversed(alignment1))
alignment2 = ''.join(reversed(alignment2))
\end{lstlisting}

\subsubsection{Funciones de Visualización}

Para que sea más fácil ver qué está pasando, armé algunas funciones auxiliares:

\begin{itemize}
    \item \texttt{print\_matrix()}: muestra la matriz de puntuación de una forma clara y ordenada, con los encabezados de las secuencias para que sea más fácil interpretarla.
    
    \item \texttt{print\_alignment()}: esta es mi favorita - te muestra el alineamiento con símbolos visuales super intuitivos:
    \begin{itemize}
        \item Un \texttt{|} cuando hay un match perfecto
        \item Un \texttt{*} para los mismatches
        \item Y un espacio en blanco donde hay gaps
    \end{itemize}
    Así de un vistazo ves qué tan bien alinearon las secuencias.
    
    \item \texttt{analyze\_alignment()}: hace el análisis cuantitativo. Te cuenta cuántos matches, mismatches y gaps hay, y calcula el porcentaje de identidad entre las secuencias.
\end{itemize}

Código para análisis de estadísticas:

\begin{lstlisting}[caption={Análisis estadístico del alineamiento}]
num_matches = 0
num_mismatches = 0
num_gaps = 0

for i in range(len(alignment1)):
    if alignment1[i] == '-' or alignment2[i] == '-':
        num_gaps += 1              # Gap
    elif alignment1[i] == alignment2[i]:
        num_matches += 1           # Match
    else:
        num_mismatches += 1        # Mismatch

longitud_total = len(alignment1)
porcentaje_identidad = (num_matches / longitud_total) * 100

print(f"Longitud del alineamiento: {longitud_total}")
print(f"Coincidencias (matches):   {num_matches}")
print(f"Desajustes (mismatches):   {num_mismatches}")
print(f"Huecos (gaps):             {num_gaps}")
print(f"Identidad:                 {porcentaje_identidad:.2f}%")
\end{lstlisting}

\subsubsection{Esquema de Puntuación Implementado}

Decidí usar un modelo de puntuación bastante directo y simple:

\begin{itemize}
    \item Match: $+1$ (le damos un punto cuando coinciden)
    \item Mismatch: $-1$ (restamos uno cuando no coinciden)
    \item Gap: $-2$ (penalizamos más los huecos)
\end{itemize}

¿Por qué estos valores? Bueno, con este esquema estamos diciendo que preferimos matchear los nucleótidos cuando sea posible, pero si hay que elegir entre un mismatch y un gap, preferimos el mismatch. Esto tiene sentido biológicamente porque las mutaciones puntuales (sustituciones) suelen ser más comunes que las inserciones o eliminaciones grandes en secuencias relacionadas evolutivamente.

Código de definición de parámetros:

\begin{lstlisting}[caption={Parámetros del modelo de puntuación}]
def needleman_wunsch(seq1, seq2, match=1, mismatch=-1, gap=-2):
    """
    Implementa el algoritmo de Needleman-Wunsch
    
    Parametros:
    - match: +1 (recompensa por coincidencia)
    - mismatch: -1 (penalizacion por desajuste)
    - gap: -2 (penalizacion por hueco)
    """
    # ... implementacion del algoritmo ...
\end{lstlisting}

Ejemplo de uso del programa:

\begin{lstlisting}[caption={Ejemplo de ejecución con parejas de secuencias}]
# Definir parejas de secuencias a analizar
parejas_secuencias = [
    ("GATTACA", "GCATGCU"),    # Caso clasico
    ("ACGT", "ACCT"),          # Secuencias cortas
    ("ATGCT", "AGCT"),         # Requiere gaps
]

# Parametros de puntuacion
MATCH = 1
MISMATCH = -1
GAP = -2

# Procesar cada pareja
for seq1, seq2 in parejas_secuencias:
    matriz, alineamiento1, alineamiento2, puntaje = \
        needleman_wunsch(seq1, seq2, MATCH, MISMATCH, GAP)
    
    # Mostrar resultados
    print_matrix(matriz, seq1, seq2)
    print_alignment(alineamiento1, alineamiento2, seq1, seq2)
    analyze_alignment(alineamiento1, alineamiento2, 
                     MATCH, MISMATCH, GAP)
\end{lstlisting}

\subsection{Casos de Prueba}

Para probar bien el programa, preparé 10 parejas diferentes de secuencias. Cada una representa un escenario distinto:

\begin{enumerate}
    \item ("GATTACA", "GCATGCU"): este es el ejemplo clásico que aparece en todos lados - tiene varios mismatches interesantes
    \item ("ACGT", "ACCT"): algo cortito y simple, solo un mismatch
    \item ("ATGCT", "AGCT"): acá necesitás introducir un gap para que salga bien el alineamiento
    \item Y así sucesivamente... incluí casos con secuencias de distintos largos, algunas muy parecidas, otras que necesitan varios gaps, etc.
\end{enumerate}

Para cada pareja, el programa te muestra un montón de info útil:
\begin{itemize}
    \item Toda la matriz de puntuación (así podés ver cómo razona el algoritmo)
    \item El alineamiento óptimo que encontró
    \item Todas las estadísticas: matches, mismatches, gaps, porcentaje de identidad
    \item Y el puntaje final que obtuvo ese alineamiento
\end{itemize}

\subsection{Características Técnicas}

\begin{itemize}
    \item Lenguaje: Python 3
    \item Complejidad temporal: $O(n \times m)$ donde $n$ y $m$ son las longitudes de las secuencias
    \item Complejidad espacial: $O(n \times m)$ para almacenar la matriz completa
    \item Documentación: el código incluye comentarios extensos explicando la teoria detrás de cada paso
    \item Modularidad: funciones separadas para diferentes aspectos del analisis, facilitando mantenimiento y reutilización
\end{itemize}

\subsection{Ejemplo de Resultado}

Para que veas cómo se ve la salida, acá está el resultado de alinear \texttt{("GATTACA", "GCATGCU")}:

\begin{verbatim}
Alineamiento óptimo:
Seq1: GATTACA
      |**|*|*
Seq2: GCATGCU

Estadísticas:
- Longitud: 7
- Matches: 3 (+3 puntos)
- Mismatches: 4 (-4 puntos)
- Gaps: 0 (+0 puntos)
- Identidad: 42.86%
- Puntaje final: -1
\end{verbatim}

Fijate que aunque comparten algunas posiciones (las que tienen el \texttt{|}), hay bastantes diferencias (los \texttt{*}). El puntaje negativo nos está diciendo que, en general, estas secuencias no son muy similares. Un 42.86\% de identidad es medio bajo - en biología, secuencias con menos del 50\% de identidad generalmente no se consideran homólogas.



\section{Referencias}

\begin{thebibliography}{9}

\bibitem{needleman1970}
Needleman, S. B., \& Wunsch, C. D. (1970). 
\textit{A general method applicable to the search for similarities in the amino acid sequence of two proteins}. 
Journal of Molecular Biology, 48(3), 443-453.
Link: \url{https://web.stanford.edu/class/sbio228/public/readings/Bioinformatics_I_Lecture6/Needleman_Wunsch_JMB_70_Global_alignment.pdf?utm_source=chatgpt.com}


\bibitem{needlemanWIKI}
Wikipedia contributors. (2025). 
\textit{Needleman–Wunsch algorithm}. 
In Wikipedia, The Free Encyclopedia.
Link: \url{https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm}

\end{thebibliography}



\end{document}